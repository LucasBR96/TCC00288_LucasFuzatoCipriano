/*

----------------------------------RESPOSTAS DAS QUESTÕES 1 A 4 AQUI.--------------------------------------------------

1 - TRANSAÇÃO, NO CONTEXTO DE BANCO DE DADOS, É QUALQUER ATIVIDADE EM QUE UM USÁRIO INTERAGE COM AO MENOS ALGUM ITEM
DO BANCO DO DE DADOS ATRAVÉS DO SGBD. TODA AS TRANSÇÃO TEM AO MENOS UMA DESSAS DUAS OPERAÇÕES BASICAS.

    READ(X) -> O PROGRAMA LE UM ITEM DE DADOS X E RETORNA O SEU VALOR PARA O USÁRIO
    WRITE( X ) -> A TRANSAÇÃO ESCREVE UM NOVO VALOR PARA O ITEM DE DADOS E MANDA PARA O BANCO

UMA TRANSAÇÃO, SE FOR FEITA COM SUCESSO, É CONFIRMADA PELO SISTEMA, CASO CONTRÁRIO, É ABORTADA.

2 - UMA TRANSAÇÃO DEVE SEGUIR O MODELO ACID

    (A)TOMICIDADE -> UMA TRANSAÇÃO É EXECUTADA POR COMPLETO, OU NÃO É EXECUTADA DE JEITO NENHUM, NÃO HA
                    MEIO TERMO.

    (C)ONSISTÊNCIA -> DEVE MANTER O BANCO DE DADOS CONSISTENTE COM SUAS REGRAS AO FINAL DA SUA EXECUÇÃO

    (I)SOLAMENTO -> A EXECUÇÃO DE UMA TRANSAÇÃO NÃO PODE SOFRER NEHUMA INTERFERÊNCIA DE TRANSAÇÕES CONCOR-
                    RENTES. OU SEJA, DEVE SER EXECUTADA COM SE ELA FOSSE A ÚNICA TRANSÇÃO DO LOG.

    (D)URABILIDADE -> UMA VEZ CONFIRMADA, NÃO PODE SER DESFEITA.

3 - UM PLANO CONCORRENTE É UM ONDE AS TRANSÇÕES EXECUTAM DE FORMA INTERCALADA, EXEMPLO.

    T1 = { R(X) , R( Y ) , X = X + Y, W( X )}
    T2 = { R(X) , R( Y ) , Y = X + Y, W( Y )}

    P = { R1( X ) , R1( Y ) , R2( X ) , R2( Y ), X = X + Y , W1( X ), Y = X + Y , W2( Y )  }

4 - LEGENDA:

    LR -> LOCK-READ
    LR -> LOCK-WRITE
    U  -> UNLOCK

    P = { LR1( Y ) , R1( Y ) , LR2( X ),  R2( X ) , U1( Y ) , LR1( X ), U2( X ), LR2( X ), R1( X ), WL1( X ), R2( Y ), WL2( Y )
         W1( X ), U1( X ), W2( Y ), U2( Y ) }

5 - UASANDO TIMESTAMPS COM O MODELO WOUND-WAIT.

    SE UMA TRANSAÇÃO T1 QUER ESCREVER SOBRE UM ELEMENTO X QUE JA ESTÁ ALOCADO A T2:
        1 - SE T2 FOR MAIS NOVO QUE T1, ABORTE T2, TOME X, E REINICIE T2.
        2 - SE T2 FOR MAIS VELHO, ESPERE T2 SER CONFIRMADO OU ABORTADO.

*/

-- QUESTÃO 6.

--------
DROP TABLE IF EXISTS
CREATE TABLE ATIVIDADE(
    ID INT PRIMARY KEY,
    NOME TEXT
);

DROP TABLE IF EXISTS
CREATE TABLE ARTISTA(
    ID INT PRIMARY KEY,
    NOME TEXT NOT NULL,
    RUA TEXT,
    CIDADE TEXT,
    ESTADO TEXT,
    CEP TEXT,
    ATIVIDADE INT,

    CONSTRAINT ARTISTA_FK FOREIGN KEY ( ATIVIDADE )
    REFERENCES ATIVIDADE( ID )
);

DROP TABLE IF EXISTS
CREATE TABLE ARENA(
    ID INT PRIMARY KEY,
    NOME TEXT NOT NULL,
    CIDADE TEXT,
    CAPACIDADE INT NOT NULL
);

DROP TABLE IF EXISTS
CREATE TABLE CONCERTO(
    ID INT PRIMARY KEY,
    ARTISTA INT,
    ARENA INT,
    INICIO TIMESTAMP,
    FIM TIMESTAMP,
    PRECO INT,

    CONSTRAINT CONCERTO_FK1 FOREIGN KEY ( ARTISA )
    REFERENCES ARTISTA( ID ),

    CONSTRAINT CONCERTO_FK2 FOREIGN KEY ( ARENA )
    REFERENCES ARENA( ID )
);

-----------------DADOS--------------------------------------------------------

INSERT INTO ATIVIDAE VALUES
( 1 , "POP" ),
( 2 , "ROCK" ),
( 3 , "REAGGE" );

INSERT INTO ARTISTA( ID , NOME , ATIVIDADE ) VALUES
( 1 , "ERIC CLAPTON", 2 ),
( 2 , "PAUL McCARTNEY", 2 ),
( 3 , "BOB MARLEY", 3 ),
( 4 , "MICHAEL JACKSON" , 1),
( 5 , "DUA LIPA" , 1);

INSERT INTO ARENA( ID , NOME , CAPACIDADE ) VALUES
( 1 , "CITYBANKHALL", 10000 ),
( 2 , "FUNDIÇÃO PROGRESSO", 10000 );


---------FUNCOES AUXILIARES --------------------------------------------

CREATE OR REPLACE FUNCTION TIMESTAMP_OVERLAP( TIMESTAMP , TIMESTAMP , TIMESTAMP , TIMESTAMP ) RETURNS BOOLEAN AS $$
DECLARE

    START_1 ALIAS FOR $1;
    END_1 ALIAS FOR $2;
    START_2 ALIAS FOR $2;
    END_2 ALIAS FOR $2;

    COND1 BOOLEAN;
    COND2 BOOLEAN;
BEGIN 

    COND1 := ( START_1 <= START_2 <= END_1 );
    COND2 := ( START_2 <= START_1 <= END_2 );

    RETURN COND1 OR COND2;
END;


$$ LANGUAGE PLPGSQL;
---------FUNCOES TRIGGER -----------------------------------------------
CREATE OR REPLACE FUNCTION OBSTRUCT_ARTIST_EXLUSION() RETURNS TRIGGER AS $$
DECLARE
    CONT INT;
BEGIN
    CONT = 0;
    SELECT COUNT( * ) INTO CONT
    FROM ARTISTA
    WHERE ATIVIDADE = OLD.ATIVIDADE;

    IF ( CONT = 1 ) THEN
        RAISE NOTICE "EXCLUSÃO OBSTRUIDA, ESSE ARTISTA É O UNICO PARA ESSA ATIVIDADE";
        RETURN NULL;
    END IF;

    RETURN OLD;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION OBSTRUCT_CONCERT_SCHEDULING() RETURNS TRIGGER AS $$
DECLARE
    CONT INT;
BEGIN
    CONT = 0;
    WITH TAB1 AS (
        SELECT INICIO , FIM FROM CONCERTO
        WHERE ( ARTISTA = NEW.ARTISTA ) OR ( ARENA = NEW.ARENA )
    )
    SELECT COUNT( * ) INTO CONT FROM TAB1 
    WHERE TIMESTAMP_OVERLAP( INICIO , FIM , NEW.INICIO , NEW.FIM );

    IF ( CONT != 0 ) THEN
        RAISE NOTICE "INSERÇÃO OBSTRUIDA, JA EXISTE ALGUMA APRESENTAÇÃO MARCADA PARA ESSE ARTISTA OU ARENA";
        RETURN NULL;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

-----TRIGGERS-----------------------------------------------------------------------------

CREATE TRIGGER T1
BEFORE DELETE ON ARTISTA
FOR EACH ROW EXECUTE FUNCTION OBSTRUCT_ARTIST_EXLUSION();

CREATE TRIGGER T2
BEFORE INSERT ON CONCERT
FOR EACH ROW EXECUTE FUNCTION OBSTRUCT_CONCERT_SCHEDULING();

---TESTES---------------------------------------------------------------------------------

DELETE FROM ARTISTA WHERE NOME = "BOB MARLEY"; -- OBSTRUIDO
DELETE FROM ARTISTA WHERE NOME = "DUA LIPA";   -- APROVADO
DELETE FROM ARTISTA WHERE NOME = "PAUL McCARTNEY"; -- APROVADO
SELECT * FROM ARTISTA;

INSERT INTO CONCERTO( ID , ARTISTA, ARENA , INICIO, FIM ) VALUES
(1 , 1 , 1 , '01/01/2000 18:00':: TIMESTAMP , '01/01/2000 21:00'::TIMESTAMP ),
(2 , 4 , 2 , '02/01/2000 18:00':: TIMESTAMP , '02/01/2000 20:00'::TIMESTAMP ),
(3 , 1 , 2 , '01/01/2000 19:00':: TIMESTAMP , '01/01/2000 21:00'::TIMESTAMP ), -- OVERLAP DE HORARIO PARA UM MESMO ARTISTA
(4 , 4 , 1 , '01/01/2000 18:00':: TIMESTAMP , '01/01/2000 20:00'::TIMESTAMP ); -- OVERLAP DE HORARIO PARA UMA MESMA ARENA
SELECT * FROM CONCERTO;